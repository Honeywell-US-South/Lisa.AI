using System.Text.Json.Serialization;

namespace Lisa.AI.OpenAIModels
{
    /// <summary>
    /// Information about tokens for inference completion
    /// </summary>
    public class ToolInfo
    {
        /// <summary>
        /// Tool type, currently supports only "function"
        /// </summary>
        public string type { get; set; } = "function";

        /// <summary>
        /// Function details
        /// </summary>
        public required FunctionInfo function { get; set; }
    }

    /// <summary>
    /// Details of the function
    /// </summary>
    public class FunctionInfo
    {
        /// <summary>
        /// Name of the function to be called. Must consist of a-z, A-Z, 0-9, underscores, or hyphens, with a maximum length of 64.
        /// </summary>
        public required string name { get; set; }

        /// <summary>
        /// Description of the function's purpose, used by the model to determine when and how to call the function.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public string? description { get; set; }

        /// <summary>
        /// Parameters accepted by the function, described as a JSON schema object.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public Parameters? parameters { get; set; }
    }

    /// <summary>
    /// Parameters of the function
    /// </summary>
    public class Parameters
    {
        /// <summary>
        /// Parameter type, currently supports only "object"
        /// </summary>
        public string type { get; set; } = "object";

        /// <summary>
        /// Properties of the parameters, described as a JSON schema object.
        /// The keys are of type ParameterInfo.
        /// </summary>
        public required Dictionary<string, ParameterInfo> properties { get; set; }

        /// <summary>
        /// List of required parameter names.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public string[]? required { get; set; }
    }

    /// <summary>
    /// Information about a parameter, used to describe function parameters
    /// </summary>
    public class ParameterInfo
    {
        /// <summary>
        /// Parameter type
        /// </summary>
        public required string type { get; set; }

        /// <summary>
        /// Description of the parameter
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public string? description { get; set; }

        /// <summary>
        /// Optional values for the parameter
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public string[]? @enum { get; set; }

        /// <summary>
        /// Indicates whether the parameter is required
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public bool? required { get; set; }
    }

    /// <summary>
    /// Tool message chunk for streaming processing
    /// </summary>
    public class ToolMessageChunk : ToolMessage
    {
        /// <summary>
        /// Index of the tool call
        /// </summary>
        public int index { get; set; }
    }

    /// <summary>
    /// Tool message
    /// </summary>
    public class ToolMessage
    {
        /// <summary>
        /// ID of the tool call
        /// </summary>
        public string id { get; set; }

        /// <summary>
        /// Tool type, currently fixed to "function"
        /// </summary>
        public string type { get; set; } = "function";

        /// <summary>
        /// Information about the called function
        /// </summary>
        public ToolMessageFuntion function { get; set; }
    }

    /// <summary>
    /// Response selection for invoking a tool
    /// </summary>
    public class ToolMessageFuntion
    {
        /// <summary>
        /// Function name
        /// </summary>
        public string name { get; set; }

        /// <summary>
        /// Parameters for calling the function, generated by the model in JSON format.
        /// Note that the model does not always generate valid JSON and might hallucinate parameters not defined in the function schema.
        /// Validate parameters in code before invoking the function.
        /// </summary>
        public string? arguments { get; set; }
    }
}
